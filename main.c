#include <stdlib.h>

#include "baseline.h"
#include "i2c.h"
#include "uart.h"
#include "ssd1306.h"

/* Note that the dev board that I am using has a button meant to help
   quickly power cycle for testing. This power cycle seems to only
   partially power off the controller, as I've noticed changes to my
   I2C code not fully carrying over if I just press the button as
   opposed to fully cutting it from power. Weird unexpected behavior
   may occur otherwise. */
/* That said, there may be a simpler explanation. It's possible I
   might have just not zoomed out fully on the logic analyzer, leading
   to me misidentifying odd behavior. I thought I did in fact zoom out
   fully several times, so I'm not sure. */
/* There 1000% is odd behavior just using the button to power cycle.
   Confirmed when I noticed I2C communication wasn't being sent at
   all, but after fully power cycling it was sent again. */


/* void second_func(int i) { */
/*   volatile char char_var = 'c'; */
/*   i -= 1; */
/*   if (i > 0) { */
/*     second_func(i); */
/*   } */
/* } */

int main() {
  const int baud_rate = 9600;
  const long fmaster = 16000000;

  clk_hsi_prescaler(1);
  uart_init(baud_rate, fmaster);
  i2c_init(2);                  /* fixme no apparent effect */
  uart_printf("\n\r------------\n\r");
  uart_printf("Started!\n\r");

  /* Initialize display */
  uint8_t data[16];
  data[0] = CONTROL_BYTE(CO_DATA, DC_COMMAND);
  data[1] = CMD_OFF;
  data[2] = CMD_TIM_DISPLAY_CLK_DIVIDE_RATIO;
  data[3] = 0x80;                /* ratio 0x80 */
  data[4] = CMD_HW_MULTIPLEX_RATIO;
  data[5] = 0x1F;                /* ratio 31 mux */
  data[6] = CMD_HW_COM_PINS_CONFIG;
  data[7] = 0x02;                /* split for 128x32 */
  data[8] = 0x20;   /* set addressing mode */
  data[9] = 0x00;   /* horiztonal addressing mode */
  data[10] = CMD_PUMP_SETTING;
  data[11] = CHARGE_PUMP_75;
  data[12] = CMD_FOLLOW_RAM;
  data[13] = CMD_NOINVERSE;
  data[14] = CMD_ON;
  delay(75000);

  int err = i2c_send_bytes(data, 15, 0x3C);
  if (err == NACK_ERROR) {
    uart_printf("NACK ERROR!!!\n\r");
  }
  /* Funny story with (char) cast. Originally send_bytes took an int in that spot, but I changed it to char in i2c.c/h for memory concerns. I then noticed that addr wasn't being sent correctly after that. Turns out I needed to recompile main.c as well! */

  const uint8_t buffer2[512] = {
    0x00, 0x00, 0x00, 0x00, 0xfc, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfc, 0x00, 0x00, 0x00, 0x80, 0xc0, 
    0x40, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xfc, 0x00, 0x00, 0x00, 
    0x00, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x40, 0x60, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xc0, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0x01, 0x01, 0x01, 0x01, 0x01, 0x7f, 0x00, 0x00, 0x00, 0x1f, 0x34, 
    0x24, 0x24, 0x26, 0x23, 0x23, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x3f, 
    0x21, 0x21, 0x21, 0x21, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x03, 0x06, 0x7e, 0x02, 0x02, 0x02, 0x01, 0x01, 0xf1, 0xb8, 0xa8, 0xa8, 0x38, 
    0x30, 0x00, 0x00, 0xf8, 0xa8, 0x38, 0x00, 0x00, 0x00, 0xe9, 0x3f, 0x10, 0x10, 0x10, 0x10, 0x00, 
    0x7f, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x20, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x40, 0x60, 0x30, 0x0c, 0x06, 0x00, 0x80, 0xc0, 0x60, 0x30, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x06, 0x1c, 0x70, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0xc0, 0x70, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x81, 0x87, 0x84, 0x84, 
    0x84, 0x04, 0x04, 0x04, 0x04, 0x04, 0xc4, 0xc4, 0x44, 0x44, 0xc4, 0x04, 0x04, 0x04, 0x05, 0xfd, 
    0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x84, 0x8c, 0xfd, 0x04, 0x04, 0x04, 0x04, 0xfc, 0x04, 
    0x05, 0x04, 0x04, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1e, 0x10, 
    0x30, 0x20, 0x20, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x63, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0e, 0x38, 0x30, 0x1c, 0x06, 0x03, 0x0f, 0x18, 0x10, 0x10, 
    0x18, 0x0c, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1b, 0x11, 0x10, 0x10, 0x18, 
    0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
    0x7c, 0x00, 0x00, 0x00, 0x1e, 0x33, 0x21, 0x21, 0x3f, 0x21, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

  /* clear display */
  data[0] = CONTROL_BYTE(CO_DATA, DC_DATA);
  data[1] = 0x00;


  /* Set address to start writing */
  data[0] = CONTROL_BYTE(CO_DATA, DC_COMMAND);
  data[1] = CMD_ADDR_COL;
  data[2] = 0;
  data[3] = 127;
  data[4] = CMD_ADDR_PAGE;
  data[5] = 0x00;
  data[6] = 0x03;
  i2c_send_bytes(data, 7, 0x3C);

  /* Problem: The display is 128x32 (512 pixels), and yet currently to
     clear it I need to send 0x00 data 1024 times. To my
     understanding, pages4-7 should not appear on the display at all,
     and we control it only through pages0-3. This is not currently
     the case. I suspect splitting HW_COM_PINS_CONFIG with 0x12 is the
     cause. I'll try some other values found on page 40 of the
     datasheet. I did notice some behavior that suggested pixels
     weren't perfectly mapped 1 to 1, but it's hard to tell since
     they're so tiny. */

  int count = 0;

  
  while (1) {
    count++;
    data[0] = CONTROL_BYTE(CO_DATA, DC_DATA);
    for (int i = 0; i < 512; i++) {
      data[1] = buffer2[i];
      i2c_send_bytes(data, 2, 0x3C);
    }

    /* for (int i = 0; i < 512; i++) { */
    /*   data[1] = 0x0F; */
    /*   i2c_send_bytes(data, 2, 0x3C); */
    /*   delay(5); */
    /* } */

    /* data[0] = CONTROL_BYTE(CO_DATA, DC_DATA); */
    /* data[1] = 0x00; */
    /* i2c_send_bytes(data, 2, 0x3C); */
  
    /* for (int i = 0; i < 512; i++) { */
    /*   data[1] = buffer2[i]; */
    /*   i2c_send_bytes(data, 2, 0x3C); */
    /* } */

    delay(500000);
    uart_printf("No stack overflow here!\n\r");
  }
  /* data[1] = random_upto(0xFF); */
  /* if (NACK_ERROR == i2c_send_bytes(data, 2, 0x3C)) { */
  /* uart_printf("err\n\r"); */
  /* } */

}
